# 11047 동전 0 - 그리디

[](https://www.acmicpc.net/problem/11047)

## 문제 조건

- (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)
- (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)

## 풀이 과정

동전의 종류가 최대 10종류여서 O(N)의 시간복잡도를 가지는 그리디 알고리즘으로 풀어도 되겠다 라고 생각했습니다. 동전 개수의 최솟값을 구하라 했으니 동전들을 내림차순 정렬하여 큰 값 부터 조건을 충족시키는지 확인하여 값을 갱신했습니다.

## 코드

```java
/**
 * 11047 동전0
 *
 * n(동전 종류), k(목표 값), A(동전 종류를 받는 1차원 배열), cost(동전의 합), count(동전 개수)
 *
 * for(0~n까지 반복) {
 *     A에 동전 종류 저장하기
 * }
 *
 * A 내림차순 정렬
 * for(i -> 0~n까지 반복) {
 *     if (A[i]<k-cost) 동전 개수와 동전의 합 갱신
 *     if (k-cost == 0) break
 * }
 */
public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());

        Integer[] A = new Integer[n];

        for(int i=0; i<n; i++) {
            A[i] = Integer.parseInt(br.readLine());
        }

        Arrays.sort(A, Collections.reverseOrder());
        int count = 0;
        for(int i=0; i<n; i++) {
            if (k-A[i] >= 0) {
                count += (k / A[i]);
                k -= A[i]*(k / A[i]);
            }
            if (k <= 0) break;
        }

        System.out.println(count);
    }
}

```